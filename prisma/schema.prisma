generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum ReviewStatus {
  PENDING
  APPROVED
  REJECTED
}

enum PropertyType {
  APARTMENT
  HOUSE
  STUDIO
}

enum BookingStatus {
  PENDING
  CONFIRMED
  CANCELLED
  REJECTED
  COMPLETED
}

enum PricingType {
  BASE
  SPECIAL
}

model User {
  id              Int       @id @default(autoincrement())
  email           String    @unique
  password        String
  name            String
  phone           String
  avatar          String?
  isVerified      Boolean   @default(false)
  verificationCode String?   
  codeExpires     DateTime? 
  
  // Поля для сброса пароля
  resetPasswordCode String?
  resetPasswordCodeExpires DateTime?
  
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt


  // Отношения
  apartments      Apartment[]
  bookings        Booking[]
  favorites       Favorite[]
  authoredReviews Review[]      @relation("ReviewAuthor")
  hostedReviews   Review[]      @relation("ReviewHost")
  tenantChats     Chat[]        @relation("TenantChats")
  hostChats       Chat[]        @relation("HostChats")
  messages        Message[]
  pricingRules    PricingRule[]

  @@map("users")
}

// Добавьте после модели User
model PendingUser {
  id              Int       @id @default(autoincrement())
  email           String    @unique
  password        String
  name            String
  phone           String
  verificationCode String
  codeExpires     DateTime
  createdAt       DateTime  @default(now())

  @@map("pending_users")
}

model Apartment {
  id            Int       @id @default(autoincrement())
  title         String
  description   String
  price         Int       // Базовая цена за ночь
  type          PropertyType
  district      String
  lat           Float?
  lng           Float?
  address       String
  rooms         Int?
  area          Int?
  floor         Int?
  amenities     String[]
  images        String[]
  isPublished   Boolean   @default(false)
  status        String    @default("PENDING") // PENDING, APPROVED, REJECTED
  isEdited      Boolean   @default(false)
  rejectionReason String?
  hostId        Int
  host          User      @relation(fields: [hostId], references: [id], onDelete: Cascade)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  publishedAt   DateTime?
  checkInTime      String   @default("14:00")
  checkOutTime     String   @default("12:00")
  cleaningTime     Int      @default(2) // в часах

  // Отношения
  bookings      Booking[]
  pricingRules  PricingRule[]
  favorites     Favorite[]
  reviews       Review[]
  chats         Chat[]

  @@map("apartments")
}

model Booking {
  id            Int           @id @default(autoincrement())
  apartmentId   Int
  apartment     Apartment     @relation(fields: [apartmentId], references: [id], onDelete: Cascade)
  userId        Int
  user          User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Даты бронирования
  startDate     DateTime
  endDate       DateTime
  
  // Статус и информация
  status        BookingStatus @default(PENDING)
  totalPrice    Int           // Итоговая стоимость брони
  comment       String?
  
  // Системные поля
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  
  // Связь с чатом (если создавался чат при бронировании)
  chatId        Int?
  chat          Chat?         @relation(fields: [chatId], references: [id], onDelete: SetNull)
  
  // Связь с сообщениями (для связи с Message.booking)
  messages      Message[]
  
  @@index([apartmentId, startDate, endDate])
  @@index([userId, status])
  @@index([startDate])
  @@map("bookings")
}

model PricingRule {
  id            Int           @id @default(autoincrement())
  apartmentId   Int
  apartment     Apartment     @relation(fields: [apartmentId], references: [id], onDelete: Cascade)
  
  // Дата, на которую установлена цена
  date          DateTime
  
  // Цена на эту дату
  price         Int
  
  // Тип цены (базовая/специальная)
  type          PricingType   @default(SPECIAL)
  
  // Кто установил цену (владелец)
  userId        Int
  user          User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt

  // Уникальный индекс: нельзя иметь две цены на одну дату для одной квартиры
  @@unique([apartmentId, date])
  @@index([date])
  @@map("pricing_rules")
}

model Admin {
  id        Int      @id @default(autoincrement())
  email     String   @unique
  password  String
  name      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("admins")
}

model Favorite {
  id          Int      @id @default(autoincrement())
  userId      Int
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  apartmentId Int
  apartment   Apartment @relation(fields: [apartmentId], references: [id], onDelete: Cascade)
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@unique([userId, apartmentId])
  @@map("favorites")
}

model Review {
  id          Int      @id @default(autoincrement())
  rating      Int
  comment     String
  status      ReviewStatus @default(PENDING)
  authorId    Int
  author      User     @relation("ReviewAuthor", fields: [authorId], references: [id], onDelete: Cascade)
  hostId      Int
  host        User     @relation("ReviewHost", fields: [hostId], references: [id], onDelete: Cascade)
  apartmentId Int?
  apartment   Apartment? @relation(fields: [apartmentId], references: [id], onDelete: Cascade)
  chatId      Int?
  chat        Chat?    @relation(fields: [chatId], references: [id], onDelete: Cascade)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@map("reviews")
}

model Chat {
  id          Int       @id @default(autoincrement())
  apartmentId Int
  apartment   Apartment @relation(fields: [apartmentId], references: [id], onDelete: Cascade)
  tenantId    Int
  tenant      User      @relation("TenantChats", fields: [tenantId], references: [id], onDelete: Cascade)
  hostId      Int
  host        User      @relation("HostChats", fields: [hostId], references: [id], onDelete: Cascade)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  
  // Отношения
  messages    Message[]
  reviews     Review[]
  bookings    Booking[]
  
  @@unique([apartmentId, tenantId])
  @@map("chats")
}

model Message {
  id        Int      @id @default(autoincrement())
  content   String
  senderId  Int
  sender    User     @relation(fields: [senderId], references: [id], onDelete: Cascade)
  chatId    Int
  chat      Chat     @relation(fields: [chatId], references: [id], onDelete: Cascade)
  isRead    Boolean  @default(false)
  createdAt DateTime @default(now())
  
  // ДОБАВЛЕНО: связь с бронированием (если сообщение о брони)
  bookingId Int?
  booking   Booking? @relation(fields: [bookingId], references: [id], onDelete: SetNull)
  
  @@map("messages")
}
